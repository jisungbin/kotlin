/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.mpp.publication

import org.gradle.api.JavaVersion
import org.gradle.util.GradleVersion
import org.jetbrains.kotlin.gradle.testbase.*
import org.jetbrains.kotlin.gradle.util.cartesianProductOf
import org.jetbrains.kotlin.gradle.util.x
import org.jetbrains.kotlin.test.KotlinTestUtils
import org.jetbrains.kotlin.test.TestMetadata
import org.jetbrains.kotlin.utils.addIfNotNull
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.extension.ExtendWith
import org.junit.jupiter.api.io.TempDir
import org.junit.jupiter.params.ParameterizedTest
import org.junit.jupiter.params.provider.MethodSource
import org.junit.runners.model.MultipleFailureException
import java.io.File
import java.nio.file.Path
import java.nio.file.Paths
import kotlin.io.path.readText

@ExtendWith(GradleParameterResolver::class)
class MppPublicationCompatibilityIT : KGPBaseTest() {
    companion object {
        private val agpVersions = listOf(
            TestVersions.AGP.MIN_SUPPORTED,
            TestVersions.AGP.MAX_SUPPORTED,
        )

        private val agpSupportedGradleVersions = TestVersions.AgpCompatibilityMatrix.entries.associateBy { it.version }

        private val kotlinVersions = listOf(
            TestVersions.Kotlin.STABLE_RELEASE,
            TestVersions.Kotlin.CURRENT
        )

        private val projectVariants = with(ProjectVariant) {
            listOf(
                native + jvm,
                native + android,
                native + jvm + android,
                javaOnly,
                androidOnly,
            )
        }

        private infix operator fun TestVersions.AgpCompatibilityMatrix.contains(gradleVersion: GradleVersion): Boolean =
            gradleVersion in minSupportedGradleVersion..maxSupportedGradleVersion

        private fun generateScenarios(gradleVersions: List<String>): Set<Scenario> {
            val projects = cartesianProductOf(gradleVersions, agpVersions, kotlinVersions, projectVariants).map {
                ScenarioProject(
                    gradleVersion = it[0] as String,
                    agpVersion = it[1] as String,
                    kotlinVersion = it[2] as String,
                    variant = it[3] as ProjectVariant,
                )
            }
                // filter out android projects if gradle version is not compatible
                .filter { if (it.isWithAndroid) it.gradleVersion in agpSupportedGradleVersions[it.agpVersionString]!! else true }
                .toSet()

            val scenarios = (projects x projects)
                .map { (consumer, producer) -> Scenario(consumer, producer) }
                // ensure that each scenario we test master KGP i.e. we are not interested in AndroidOnly <-> JavaOnly compatibility
                .filter { scenario -> scenario.consumer.isMasterKmp || scenario.producer.isMasterKmp }
                // ensure that JavaOnly can consume KMP project i.e. it should have JVM part
                .filter { scenario -> if (scenario.consumer.isJavaOnly) scenario.producer.isWithJvm else true }
                .filter { scenario -> if (scenario.consumer.isWithAndroid) scenario.producer.isWithAndroid else true }
                .toSet()
            println("Total scenarios: ${scenarios.size}")
            println("Total unique publications: ${scenarios.map { it.producer }.toSet().size}")
            println("Total unique consumer projects: ${scenarios.map { it.consumer }.toSet().size}")

            return scenarios
        }

        @JvmStatic
        fun scenarios(specificGradleVersion: GradleVersion?): Iterable<Scenario> {
            val supportedGradleVersions = listOf(
                TestVersions.Gradle.MIN_SUPPORTED,
                TestVersions.Gradle.MAX_SUPPORTED,
            )

            if (specificGradleVersion != null) {
                if (specificGradleVersion.version !in supportedGradleVersions) return emptyList()
                println("Generate scenarios for $specificGradleVersion Gradle version")
                return generateScenarios(listOf(specificGradleVersion.version))
            } else {
                println("Generate scenarios for $supportedGradleVersions Gradle versions")
                return generateScenarios(supportedGradleVersions)
            }
        }

        @JvmStatic
        fun rerunScenariosForDebugging(specificGradleVersion: GradleVersion?): Iterable<Scenario> {
            val rerunIndex = 45
            return listOf(scenarios(specificGradleVersion).toList()[rerunIndex])
        }

        @JvmStatic
        @TempDir
        lateinit var localRepoDir: Path
    }


    // Test data could be regenerated by removing subdirectories in "expectedData" directory in the project dir
    @DisplayName("test compatibility between published libraries by kotlin multiplatform, java and android")
    @TestMetadata("mppPublicationCompatibility")
    @MppGradlePluginTests
    @ParameterizedTest()
    @MethodSource("scenarios")
    fun testKmpPublication(scenario: Scenario) {
        scenario.producer.publish(localRepoDir)
        scenario.testConsumption(localRepoDir)
    }

    private fun Scenario.Project.publish(repoDir: Path) {
        // check if already published
        if (repoDir.resolve(packageName.replace(".", "/")).resolve(artifactName).toFile().exists()) return

        val sampleDirectoryName = variant.sampleDirectoryName
        val scenarioProject = this
        project(
            projectName = "mppPublicationCompatibility/sampleProjects/$sampleDirectoryName",
            gradleVersion = gradleVersion,
            localRepoDir = repoDir,
            buildJdk = File(System.getProperty("jdk${JavaVersion.VERSION_17.majorVersion}Home"))
        ) {
            prepareProjectForPublication(scenarioProject)
            val buildOptions = if (isWithAndroid) {
                val androidVersion = scenarioProject.agpVersionString!!
                defaultBuildOptions.copy(androidVersion = androidVersion)
            } else {
                defaultBuildOptions
            }
            build("publish", buildOptions = buildOptions, forceOutput = true)
        }
    }

    private fun Scenario.testConsumption(repoDir: Path) {
        val consumerDirectory = consumer.variant.sampleDirectoryName

        project(
            projectName = "mppPublicationCompatibility/sampleProjects/$consumerDirectory",
            gradleVersion = consumer.gradleVersion,
            localRepoDir = repoDir,
            buildJdk = File(System.getProperty("jdk${JavaVersion.VERSION_17.majorVersion}Home"))
        ) {
            prepareConsumerProject(consumer, listOf(producer), localRepoDir)
            val buildOptions = if (consumer.isWithAndroid) {
                val androidVersion = consumer.agpVersionString!!
                defaultBuildOptions.copy(androidVersion = androidVersion)
            } else {
                defaultBuildOptions
            }

            build("resolveDependencies", buildOptions = buildOptions, forceOutput = true)

            val failures = mutableListOf<Throwable>()
            for (configurationName in consumer.resolvedConfigurationsNames) {
                val actualReport = projectPath.resolve("resolvedDependenciesReports")
                    .resolve("${configurationName}.txt")
                    .readText()

                val expectedReportFile = expectedResolvedConfigurationTestReport(configurationName)
                val actualReportSanitized = actualReport
                    .lineSequence()
                    .filterNot { it.contains("stdlib") }
                    .map { it.replace(TestVersions.Kotlin.CURRENT, "SNAPSHOT") }
                    .joinToString("\n")

                val result = kotlin.runCatching {
                    KotlinTestUtils.assertEqualsToFile(expectedReportFile.toFile(), actualReportSanitized)
                }
                failures.addIfNotNull(result.exceptionOrNull())
            }

            if (failures.isNotEmpty()) {
                throw MultipleFailureException(failures)
            }
        }
    }
}

private fun Scenario.expectedResolvedConfigurationTestReport(configurationName: String): Path {
    return Paths.get(
        "src",
        "test",
        "resources",
        "testProject",
        "mppPublicationCompatibility",
        "expectedData",
        "consumer_" + consumer.id,
        "producer_" + producer.id,
        "$configurationName.txt"
    )
}

private val ProjectVariant.sampleDirectoryName: String
    get() = when (this) {
        ProjectVariant.AndroidOnly -> "androidOnly"
        ProjectVariant.JavaOnly -> "javaOnly"
        is ProjectVariant.Kmp -> "kmp"
    }
